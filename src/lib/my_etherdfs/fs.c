/*
 * This file is part of the ethersrv-linux project
 * Copyright (C) 2017 Mateusz Viste
 */

#include <assert.h>
//#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
//#include <sys/statvfs.h> /* statvfs() for diskfree calls */
//#include <sys/stat.h>    /* stat() */
#include <sys/types.h>
#include <stdio.h>
#include <stdint.h>
//#include <stdlib.h>        /* free() */
#include <string.h>
//#include <time.h>        /* time_t, struct tm... */
#include <unistd.h>
//#include <linux/msdos_fs.h>
//#include <sys/ioctl.h>
#include <string.h>

#include "debug.h"

#ifdef BOARD_PICOMEM

#include "pico/stdlib.h"
#include "f_util.h"
#include "ff.h"
#include "../pm_debug.h"
//#include "../pm_gvars.h"

bool PM_EnablePSRAM();
bool PM_EnableSD();

//List of files indexed by their "ID"
// ID are then stored to the File "SFT" structure, in the "Cluster number" variable, as Handle is generated by DOS
#define MAXFILES 16

bool pm_fileopened[MAXFILES];
FIL pm_files[MAXFILES]; // 16 Files maximum  > To change to pointer ?
uint32_t pm_filesize[MAXFILES]; // File size

DIR dir_find;       /* Find directory object */

#else
#endif

#include "fs.h" /* include self for control */

#ifdef BOARD_PICOMEM

// The opened files is a list of MAXFILES "FIL" type structure

void init_fobj()
{
   for (uint8_t i=0;i<MAXFILES;i++) pm_fileopened[i]=false;
}

void free_fobj(uint8_t fid)
{
  if (fid<MAXFILES) 
  {
    //PM_INFO("!!FREE %d\n",fid);
    pm_fileopened[fid]=false;
  }
}

// Get the file object @ from its ID
FIL *get_fobj(uint8_t fid)
{
  //PM_INFO("Getfobj %d opened? %d\n",fid,pm_fileopened[fid]);
  if ((fid<MAXFILES)&&(pm_fileopened[fid])) 
     {
      //PM_INFO("!!NEW %d\n",fid);
      return &pm_files[fid];
     }
//  PM_INFO("Getfobj fail\n");
  return NULL;
}

// allocate a new file object and get its ID, return NULL if no more objects
FIL *new_fobj(uint8_t *fid)
{
 for (uint8_t i=0;i<MAXFILES;i++)
   if (!pm_fileopened[i]) 
      {
       //PM_INFO("new_fobj id:%d ptr:%x\n",i,&pm_files[i]);
       *fid=i;
       pm_fileopened[i]=true;
       return &pm_files[i];
      }
 return NULL;
}
#endif

/* turns a character c into its upper-case variant */
char upchar(char c) {
  if ((c >= 'a') && (c <= 'z')) c -= ('a' - 'A');
  return(c);
}

/* turns a string into all-upper-case characters, up to n chars max */
static void upstring(char *s, int n) {
  while ((n-- != 0) && (*s != 0)) {
    *s = upchar(*s);
    s++;
  }
}

/* translates a filename string into a fcb-style block ("FILE0001TXT") */
void filename2fcb(char *d, char *s) {
  int i;
  int j;
  /* fill the FCB block with spaces */
  for (i = 0; i < 11; i++) d[i] = ' ';

  /* cover '.' and '..' entries */
  for (i = 0; i < 8; i++) {
    if (s[i] != '.') break;
    d[i] = '.';
  }
  
  /* fill in the filename, up to 8 chars or first dot, whichever comes first */
  j = i;

  for (; i < 8; i++) {
    if ((s[j] == '.') || (s[j] == 0)) break;
    while ((s[j]) == ' ') {
      j++;
    }
    d[i] = upchar(s[j]);
    j++;
  }

  s += i;
  /* fast forward to either the first dot or NULL-terminator */
  for (; ((*s != '.') && (*s != 0)); s++);
  if (*s == 0) return;
  s++; /* skip the dot */
  /* fill in the extension */
  d += 8;
  for (j = 0; j < 3; j++) {
    if ((s[j] == '.') || (s[j] == 0) || (s[j] == ' ')) break;
    *d = upchar(s[j]);
    d++;
  }
}

/* converts a time_t into a DWORD with DOS (FAT-style) timestamp bits
               24                16                 8                 0
+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
|Y|Y|Y|Y|Y|Y|Y|M| |M|M|M|D|D|D|D|D| |h|h|h|h|h|m|m|m| |m|m|m|s|s|s|s|s|
+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
 \___________/\________/\_________/ \________/\____________/\_________/
    year        month       day        hour       minute      seconds */
static unsigned long time2dos(time_t t) {
  unsigned long res;
#ifdef BOARD_PICOMEM
 res= (((2025-1980)&0x3F)<<25)+(1<<21)+(20<<11); // Test : Return 1st January 2025
 //res=pico_rtc_getDOSDate();
#else  
  struct tm *ltime;
  ltime = localtime(&t);
  res = ltime->tm_year - 80; /* tm_year is years from 1900, while FAT needs years from 1980 */
  res <<= 4;
  res |= ltime->tm_mon + 1; /* tm_mon is in range 0..11 while FAT expects 1..12 */
  res <<= 5;
  res |= ltime->tm_mday;
  res <<= 5;
  res |= ltime->tm_hour;
  res <<= 6;
  res |= ltime->tm_min;
  res <<= 5;
  res |= (ltime->tm_sec >> 1); /* DOS stores seconds divided by two */
#endif
  return(res);
}

/* match FCB-style filename to a FCB-style mask ("FILE0001???"), returns 0 if
 * matching, non-zero otherwise - a FCB block is *exactly* 11 bytes long */
static int matchfile2mask(char *msk, char *fil) {
  int i;
  /* compare filename to mask */
  for (i = 0; i < 11; i++) {
    if ((upchar(fil[i]) != upchar(msk[i])) && (msk[i] != '?')) return(-1);
  }
  return(0);
}


/* provides DOS-like attributes for item i, as well as size, filling fprops
 * accordingly. returns item's attributes or 0xff on error.
 * DOS attr flags: 1=RO 2=HID 4=SYS 8=VOL 16=DIR 32=ARCH 64=DEVICE */
//http://elm-chan.org/fsw/ff/doc/chmod.html
unsigned char getitemattr(char *i, struct fileprops *fprops) {
 FRESULT fr;
 FILINFO fno;

 PM_EnableSD();
 fr = f_stat(i, &fno);
 PM_EnablePSRAM();
 switch (fr) {
     case FR_OK:
        /* zero out struct and set timestamp & fcbname */
        memset(fprops, 0, sizeof(struct fileprops));    
        fprops->ftime = fno.ftime + (fno.fdate << 16); 
        fprops->fsize=(uint32_t) fno.fsize;
        fprops->fattr=fno.fattrib;
        if (fno.altname[0]==0)  //If no alternate name, use name
           { filename2fcb(fprops->fcbname,fno.fname); }
           else filename2fcb(fprops->fcbname,fno.altname);    
// Debug Display               
        PM_INFO("Size: %lu\n", (uint32_t) fno.fsize);
        PM_INFO("Timestamp: %u-%02u-%02u, %02u:%02u\n",
               (fno.fdate >> 9) + 1980, fno.fdate >> 5 & 15, fno.fdate & 31,
               fno.ftime >> 11, fno.ftime >> 5 & 63);
        PM_INFO("Attributes: %c%c%c%c%c\n",
               (fno.fattrib & AM_DIR) ? 'D' : '-',
               (fno.fattrib & AM_RDO) ? 'R' : '-',
               (fno.fattrib & AM_HID) ? 'H' : '-',
               (fno.fattrib & AM_SYS) ? 'S' : '-',
               (fno.fattrib & AM_ARC) ? 'A' : '-');
        break;
     default : return (0xFF); // 0xFF is the error return of this fonction
    }
 return (fno.fattrib);
}

/* set attributes fattr on file i. returns 0 on success, non-zero otherwise. */
int setitemattr(char *i, unsigned char fattr) {
  FRESULT f_res;
  PM_EnableSD();  
  f_res = f_chmod(i,fattr,AM_RDO | AM_SYS | AM_HID | AM_ARC);
  PM_EnablePSRAM();
  printf("SET %u to %s!!\n",fattr,i);  
  if(f_res != F_OK) return(-1);
  return 0;  
}

int fs_find(bool Dofindfirst, char *path, char *pattern, struct fileprops *f, unsigned char fattr)
{

  FRESULT fr;   /* Return value */
//  DIR dj;       /* Directory object is sd_dir_find */
  FILINFO fno;  /* File information */
  bool ffound=false;

  memset(&fno, 0, sizeof fno);

  PM_EnableSD();
  if (Dofindfirst)  // findfirst will create the directory object and search from first file
    {
      PM_INFO("Find First -%s%-11s Attr %x\n",path,pattern,fattr);
      memset(&dir_find, 0, sizeof dir_find);       // Clean the directory object for Find First
      //fr = f_findfirst(&dir_find, &fno, path, pattern);
      fr = f_opendir(&dir_find,path);
      if (FR_OK != fr) {
        PM_INFO("f_findfirst error: %s (%d)\n", FRESULT_str(fr), fr);
          return (-1);  // > Return directly if error
         }      
    } else
    {               // findnext reuse the directory object
      PM_INFO("Find Next -%s%-11s Attr %x\n",path,pattern,fattr);
    }
  PM_EnablePSRAM();

 do {
  PM_EnableSD();
  fr = f_readdir(&dir_find, &fno);
  PM_EnablePSRAM();
  if (FR_OK != fr) {
    PM_INFO("f_find error: %s (%d)\n", FRESULT_str(fr), fr);
      return (-1);  // > Return directly if error
     }

	DWORD	dptr;			/* Current read/write offset */
  PM_INFO("File: %s,%s,  size %d attr %x DirPtr:%d\n",fno.fname,fno.altname,(uint32_t) fno.fsize, fno.fattrib ,dir_find.dptr);

  // if the file searched is Volume name and first found file is not, quit
  if (fattr == FAT_VOL) // Volume name requested ?
      {
      if (fno.fattrib & FAT_VOL)
        {
         if (strlen(fno.altname)==0) filename2fcb(f->fcbname,fno.fname);
            else filename2fcb(f->fcbname,fno.altname);          
        }
       else
        { // If no volume name, return "PICOMEM"
         filename2fcb(f->fcbname,"PICOMEM");
        }
      f->fattr=0x08;
      return 0; // > Return directly if Volume Name search
     }

  if (fno.fname[0]==0) return(-1) ;  // > Return directly if no more file

// Does not return Folder, System, Hidden ,except if the bit is set for them
  if ((fattr | (fno.fattrib & 0x16)) == fattr) 
     { // File type match > Compare the name with the pattern
      if (fno.altname[0]==0)  //If no alternate name, use name
      { filename2fcb(f->fcbname,fno.fname); }
       else filename2fcb(f->fcbname,fno.altname);
       PM_INFO(" > Compare %11s with %11s ",f->fcbname,pattern);
       if (matchfile2mask(pattern,f->fcbname) == 0) 
        { PM_INFO(" > Found\n");
          ffound=true;
        } else PM_INFO(" > Not Found\n");
      }

  } while (ffound==false);

  f->fsize=(uint32_t) fno.fsize;
  f->fattr=fno.fattrib;
  f->ftime=fno.ftime + (fno.fdate << 16);
  if (f->ftime==0) f->ftime=1;

  PM_INFO(" > Return: %s, size: %d, attr %x\n", f->fcbname,f->fsize,f->fattr );
  PM_INFO("Timestamp: %u-%02u-%02u, %02u:%02u\n",
               (fno.fdate >> 9) + 1980, fno.fdate >> 5 & 15, fno.fdate & 31,
               fno.ftime >> 11, fno.ftime >> 5 & 63);
  PM_INFO("Attributes: %c%c%c%c%c\n",
               (fno.fattrib & AM_DIR) ? 'D' : '-',
               (fno.fattrib & AM_RDO) ? 'R' : '-',
               (fno.fattrib & AM_HID) ? 'H' : '-',
               (fno.fattrib & AM_SYS) ? 'S' : '-',
               (fno.fattrib & AM_ARC) ? 'A' : '-');
  return 0;
}


/* creates or truncates a file f in directory d with attributes attr. returns 0 on success (and f filled), non-zero otherwise. */
int createfile(struct fileprops *f, char *d, char *fn, unsigned char attr) {
#ifdef BOARD_PICOMEM
  return -1;
#else  
  char fullpath[DIR_MAX];
  FILE *fd;
  sprintf(fullpath, "%s/%s", d, fn);
  /* try to create/truncate the file */
  fd = fopen(fullpath, "wb");
  if (fd == NULL) return(-1);
  fclose(fd);
  /* set attribs (only if FAT drive) */
  if (fatflag != 0) {
    if (setitemattr(fullpath, attr) != 0) PM_ERROR("Error: failed to set attribute %02Xh to '%s'\n", attr, fullpath);
  }
  /* collect and set attributes */
  getitemattr(fullpath, f);
  return(0);
#endif  
}

/* returns disks total size, in bytes, or 0 on error. also sets dfree to the
 * amount of available bytes */
unsigned long long diskinfo(char *path, unsigned long long *dfree) {
  FATFS *fs;
  unsigned long fre_clust;

  /* Get volume information and free clusters of drive */
   PM_EnableSD();
   if (f_getfree(path, &fre_clust, &fs)) return(0);
   PM_EnablePSRAM();

   PM_INFO("Free Clusters %d Clust size %d",fre_clust,fs->csize);

  /* Return total sectors and free sectors */
   *dfree = (unsigned long long) fre_clust * fs->csize * 512;
   return((unsigned long long) (fs->n_fatent - 2) * fs->csize * 512);  
}

/* try to create directory, return 0 on success, non-zero otherwise */
int makedir(char *d) {
  FRESULT fr;
  PM_EnableSD();
  f_mkdir(d);
  PM_EnablePSRAM();
    if (FR_OK != fr) {
        PM_INFO("f_mkdir error: %s (%d)\n", FRESULT_str(fr), fr);
        return (-1);
    }
  return(0);
}

/* try to remove directory, return 0 on success, non-zero otherwise */
int remdir(char *d) {
  FRESULT fr;
  //TODO: Make sure this is a directory and not a file
  PM_EnableSD();  
  fr = f_unlink(d);
  PM_EnablePSRAM();
  if (FR_OK != fr) {
    PM_INFO("f_unlink error: %s (%d)\n", FRESULT_str(fr), fr);
    return (-1);
}
  return 0;  
}

/* change to directory d, return 0 if worked, non-zero otherwise (used
 * essentially to check whether the directory exists or not) */
int changedir(char *d) {
  FRESULT fr;
  PM_EnableSD();
  fr=f_chdir(d);
  PM_EnablePSRAM();
    if (FR_OK != fr) {
      PM_INFO("f_chdir error: %s (%d)\n", FRESULT_str(fr), fr);
        return (-1);
    }
  return(0);
}

// Read the file properties after a file is opened
void get_filestats(char *filepath, struct fileprops *f)
{
 FRESULT fr;   /* Return value */
 FILINFO fno;  /* File information */

PM_EnableSD();
fr = f_stat(filepath, &fno);  //  Get the opened file info
PM_EnablePSRAM();
if (fr!=FR_OK) PM_INFO("! f_stat error : %d\n",fr);

if (strlen(fno.altname)==0)  //If no alternate name, use name
   {
    if (strlen(fno.fname)==0) PM_INFO("Err: Open file with empty name ?\n");
    filename2fcb(f->fcbname,fno.fname);
   }
    else filename2fcb(f->fcbname,fno.altname);

f->fsize=(uint32_t) fno.fsize;
f->fattr=fno.fattrib;
f->ftime=fno.ftime + (fno.fdate << 16);

PM_INFO(" > Opened: %-11s, size: %d, attr %x\n", f->fcbname,(uint32_t) f->fsize,f->fattr );
PM_INFO("Timestamp: %u-%02u-%02u, %02u:%02u\n",
             (fno.fdate >> 9) + 1980, fno.fdate >> 5 & 15, fno.fdate & 31,
             fno.ftime >> 11, fno.ftime >> 5 & 63);
PM_INFO("Attributes: %c%c%c%c%c\n",
             (fno.fattrib & AM_DIR) ? 'D' : '-',
             (fno.fattrib & AM_RDO) ? 'R' : '-',
             (fno.fattrib & AM_HID) ? 'H' : '-',
             (fno.fattrib & AM_SYS) ? 'S' : '-',
             (fno.fattrib & AM_ARC) ? 'A' : '-');
}

/*
int createfile(struct fileprops *f, char *filepath, unsigned char f_mode) {
  FIL *fd;
  FRESULT fr; 
  FILINFO fno;
  uint8_t fileid;

  printf("openfile %s mode %x \n",filepath,f_mode);

  fd = new_fobj(&fileid);                // Search if an handle is free and send the file object
  if (fd == NULL) return(-ERR_NOHANDLE); // No more handle available

  PM_EnableSD();
  fr = f_open(fd, filepath, FA_CREATE_ALWAYS);
  PM_EnablePSRAM();

  // Return the DOS error code as negative value
	switch(fr)
   {
    case FR_OK: break;
    case FR_NO_FILE: return(-ERR_FILE_NOTFOUND);
    case FR_NO_PATH: return(-ERR_PATH_NOTFOUND);
    case FR_DENIED : return(-ERR_ACC_DENIED);
    default : return (-ERR_ACC_DENIED);
   }

  PM_EnableSD();
  fr = f_stat(filepath, &fno);  //  Get the opened file info
  PM_EnablePSRAM();
  if (fr!=FR_OK) PM_INFO("! f_stat error : %d\n",fr);

  if (strlen(fno.altname)==0)  //If no alternate name, use name
     {
      if (strlen(fno.fname)==0) PM_INFO("Err: Open file with empty name ?\n");
      filename2fcb(f->fcbname,fno.fname);
     }
      else filename2fcb(f->fcbname,fno.altname);

  f->fsize=(uint32_t) fno.fsize;
  f->fattr=fno.fattrib;
  f->ftime = fno.ftime + (fno.fdate << 16);

  PM_INFO(" > Opened: %-11s, size: %d, attr %x\n", f->fcbname,(uint32_t) f->fsize,f->fattr );
  PM_INFO("Timestamp: %u-%02u-%02u, %02u:%02u\n",
               (fno.fdate >> 9) + 1980, fno.fdate >> 5 & 15, fno.fdate & 31,
               fno.ftime >> 11, fno.ftime >> 5 & 63);
  PM_INFO("Attributes: %c%c%c%c%c\n",
               (fno.fattrib & AM_DIR) ? 'D' : '-',
               (fno.fattrib & AM_RDO) ? 'R' : '-',
               (fno.fattrib & AM_HID) ? 'H' : '-',
               (fno.fattrib & AM_SYS) ? 'S' : '-',
               (fno.fattrib & AM_ARC) ? 'A' : '-');


 return (fileid);
}
*/

// Open a file using the open mode
// return the "fss" / handle number, or error (negative value)
// Open mode : 000 : Read only
//             001 : Write only
//             010 : Read/Write

/* File access mode and open method flags (3rd argument of f_open) */
/*
#define	FA_READ				0x01
#define	FA_WRITE			0x02
#define	FA_OPEN_EXISTING	0x00
#define	FA_CREATE_NEW		  0x04
#define	FA_CREATE_ALWAYS	0x08
#define	FA_OPEN_ALWAYS		0x10
#define	FA_OPEN_APPEND		0x30
*/
int openfile(struct fileprops *f, char *filepath, unsigned char f_mode) {
  FIL *fd;
  FRESULT fr; 
  FILINFO fno;
  uint8_t fileid;

  PM_INFO("openfile %s mode %x %c%c%c%c\n",filepath,f_mode,
    (f_mode & FA_READ) ? 'R' : '-',
    (f_mode & FA_WRITE) ? 'W' : '-',
    (f_mode & FA_CREATE_NEW) ? 'N' : '-',
    (f_mode & FA_CREATE_ALWAYS) ? 'A' : '-');

  fd = new_fobj(&fileid);                // Search if an handle is free and send the file object
  if (fd == NULL) return(-ERR_NOHANDLE); // No more handle available

  PM_EnableSD();
  fr = f_open(fd, filepath, f_mode);
  PM_EnablePSRAM();
  if (fr!=FR_OK) free_fobj(fileid);      // Free the file object if can't be opened

  // if error, return the DOS error code as negative value
	switch(fr)
  {
    case FR_OK: break;
    case FR_DISK_ERR : return(-ERR_DRIVE_NOTREADY);
    case FR_NO_FILE: return(-ERR_FILE_NOTFOUND);
    case FR_NO_PATH: return(-ERR_PATH_NOTFOUND);
    case FR_DENIED : return(-ERR_ACC_DENIED);
    default: return (-ERR_ACC_DENIED);
  } 

  PM_EnableSD();
  fr = f_stat(filepath, &fno);  //  Get the opened file info
  PM_EnablePSRAM();
  if (fr!=FR_OK) PM_INFO("! f_stat error : %d\n",fr);

  if (strlen(fno.altname)==0)  //If no alternate name, use name
     {
      if (strlen(fno.fname)==0) PM_INFO("Err: Open file with empty name ?\n");
      filename2fcb(f->fcbname,fno.fname);
     }
      else filename2fcb(f->fcbname,fno.altname);

  pm_filesize[fileid]=fno.fsize;  // Save the file size for getfopsize
  f->fsize=(uint32_t) fno.fsize;
  f->fattr=fno.fattrib;
  f->ftime=fno.ftime + (fno.fdate << 16);

  PM_INFO(" > Opened: %-11s, size:%d, attr:%x, fid:%d\n", f->fcbname,(uint32_t) f->fsize,f->fattr, fileid);
  PM_INFO("Timestamp: %u-%02u-%02u, %02u:%02u\n",
               (fno.fdate >> 9) + 1980, fno.fdate >> 5 & 15, fno.fdate & 31,
                fno.ftime >> 11, fno.ftime >> 5 & 63);
  PM_INFO("Attributes: %c%c%c%c%c\n",
               (f->fattr & AM_DIR) ? 'D' : '-',
               (f->fattr & AM_RDO) ? 'R' : '-',
               (f->fattr & AM_HID) ? 'H' : '-',
               (f->fattr & AM_SYS) ? 'S' : '-',
               (f->fattr & AM_ARC) ? 'A' : '-');

 return (fileid);
}

void closefile(unsigned char fid) {
  FIL *fd;
  FRESULT fr;

  PM_INFO("closefile fid:%d\n",fid);
  fd = get_fobj(fid);
  if (fd!=NULL)
     {
      PM_EnableSD();
      fr = f_close(fd);
      PM_EnablePSRAM();
      free_fobj(fid);
     }
}


/* reads len bytes from file starting at sector fss, from offset, writes to
 * buff. returns amount of bytes read or a negative value on error. */
int readfile(unsigned char *buff, uint8_t fid, uint32_t offset, uint16_t len) {
  int bread;
  FIL *fd;
  FRESULT fr;

  PM_INFO("readfile id %d, offs:%d, len/%d\n",fid,offset,len);

  fd = get_fobj(fid);
//  PM_INFO(" > FD: %x",fd);
  if (fd == NULL) return(-ERR_INVALID_HAND); // No more handle available

  PM_EnableSD();
  fr = f_lseek(fd,offset);
  if (fr==FR_OK) fr = f_read(fd, buff, len, &bread);
  PM_EnablePSRAM();
 // PM_INFO(" f_read fr %d, bread%d\n",fr,bread);

// Return the DOS error code as negative value
switch(fr)
  {
    case FR_OK: break;
    case FR_DISK_ERR : return(-ERR_DRIVE_NOTREADY);
    case FR_NO_FILE: return(-ERR_FILE_NOTFOUND);
    case FR_NO_PATH: return(-ERR_PATH_NOTFOUND);
    case FR_DENIED : return(-ERR_ACC_DENIED);
    default: return (-ERR_ACC_DENIED);
  }
  PM_INFO("Data: ");
  for (int i=0;i<16;i++)
      PM_INFO("%x,",buff[i]);
  PM_INFO("\n");
  return(bread);
}

/* writes len bytes from buff to file starting at sect fss, starting at
 * offset. returns amount of bytes written or a negative value on error. */
long writefile(unsigned char *buff, unsigned short fid, unsigned long offset, unsigned short len) {
  int bwritten;
  FIL *fd;
  FRESULT fr;

  PM_INFO("write id %d, offs:%d, len/%d\n",fid,offset,len);

  fd = get_fobj(fid);
//  PM_INFO(" > FD: %x",fd);
  if (fd == NULL) return(-ERR_INVALID_HAND); // No more handle available

  PM_EnableSD();
  fr = f_lseek(fd,offset);
  if (fr==FR_OK) fr = f_write(fd, buff, len, &bwritten);
  PM_EnablePSRAM();
 
  PM_INFO(" f_write fr %d, bread%d\n",fr,bwritten);

// Return the DOS error code as negative value
switch(fr)
  {
    case FR_OK: break;
    case FR_DISK_ERR : return(-ERR_DRIVE_NOTREADY);
    case FR_NO_FILE: return(-ERR_FILE_NOTFOUND);
    case FR_NO_PATH: return(-ERR_PATH_NOTFOUND);
    case FR_DENIED : return(-ERR_ACC_DENIED);
    default: return (-ERR_ACC_DENIED);
  }

  return(bwritten);
  
}

/* remove all files matching the pattern, returns the number of removed files if any found,
 * or -1 on error or if no matching file found */
int delfiles(char *pattern) {
  FRESULT f_res;

  unsigned int i, dcount, fileoffset = 0;
  int ispattern = 0;
  char patterncopy[DIR_MAX];
  char fname[DIR_MAX];
  char dirnamefcb[12];
  char *dir, *fil;
  char filfcb[12];
  struct dirent *diridx;
  DIR dp;
  FILINFO fno;

  /* scan the pattern for '?' characters, and find where the file part starts, also copy the pattern to patterncopy[] */
  for (i = 0; pattern[i] != 0; i++) {
    if (pattern[i] == '?') ispattern = 1;
    if (pattern[i] == '/') fileoffset = i;
    patterncopy[i] = pattern[i];
  }
  patterncopy[i] = 0;
  /* if regular file, delete it right away*/
  if (ispattern == 0) {
    
    PM_EnableSD();
    f_res = f_unlink(pattern);
    PM_EnablePSRAM();
    switch(f_res)
      {
       case FR_OK: break;
       case FR_DISK_ERR : return(-ERR_DRIVE_NOTREADY);
       case FR_NO_FILE: return(-ERR_FILE_NOTFOUND);
       case FR_NO_PATH: return(-ERR_PATH_NOTFOUND);
       case FR_DENIED : return(-ERR_ACC_DENIED);
       default: return (-ERR_ACC_DENIED);
      } 
    return(1);
  }

  /* if pattern, get dir and fil parts and iterate over all directory */
  dcount = 0;
  dir = patterncopy;
  patterncopy[fileoffset] = 0;
  fil = patterncopy + fileoffset + 1;
  filename2fcb(filfcb, fil);
  /* iterate over the directory and delete whatever is matching the pattern */

  PM_EnableSD();
  f_res = f_opendir(&dp,dir);    
  if(f_res != F_OK) {
    f_closedir(&dp);
    PM_EnablePSRAM();
    return (-1);  
  }
  PM_EnablePSRAM();

  for (;;) {
    PM_EnableSD();
    f_res = f_readdir(&dp,&fno);    
    PM_EnablePSRAM();
    if(f_res != FR_OK || fno.fname[0] == 0) break;            
    /* skip directories */
    if(fno.fattrib & FAT_DIR) continue;  
      if (fno.altname[0]==0)  //If no alternate name, use name
      { filename2fcb(dirnamefcb,fno.fname); }
       else filename2fcb(dirnamefcb,fno.altname);      
    printf("[%s]\n",fno.fname);
    /* if match, delete the file and continue */
    if (matchfile2mask(filfcb, dirnamefcb) == 0) {
      sprintf(fname, "%s/%s", dir, fno.fname);
      printf("unlink %s\n",fname);
      PM_EnableSD();      
      f_res = f_unlink(fname);      
      PM_EnablePSRAM();
      if (f_res != F_OK) fprintf(stderr, "failed to delete '%s'\n", fname);
         else dcount++;
    }
  }
  PM_EnableSD();  
  f_closedir(&dp);
  PM_EnablePSRAM();
 
  return(dcount);
}

/* rename fn1 into fn2 */
int renfile(char *fn1, char *fn2) {
  FRESULT fr;
  PM_EnableSD();
  fr = f_rename(fn1, fn2);
  PM_EnablePSRAM();

  switch(fr)
      {
       case FR_OK: break;
       case FR_DISK_ERR : return(-ERR_DRIVE_NOTREADY);
       case FR_NO_FILE: return(-ERR_FILE_NOTFOUND);
       case FR_NO_PATH: return(-ERR_PATH_NOTFOUND);
       case FR_DENIED : return(-ERR_ACC_DENIED);
       default: return (-ERR_ACC_DENIED);
      } 

  return(rename(fn1, fn2));
}

/* returns the size of an open file (or -1 on error) */
long getfopsize(unsigned short fid) {
  FIL *fd;
  FRESULT fr;
  FILINFO fno;
  if (pm_fileopened[fid]==false) return(-ERR_INVALID_HAND);
  return(pm_filesize[fid]);
}