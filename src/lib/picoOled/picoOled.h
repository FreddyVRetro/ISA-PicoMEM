#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "hardware/i2c.h"

// declare an OLED structure
// t_OledParams myOled;

// initialize the structure elements
//     myOled->i2c         = i2c0;
//     myOled->SDA_PIN     = 0;
//     myOled->SCL_PIN     = 1;

//     myOled->ctlrType    = CTRL_SH1106;
//     myOled->i2c_address = 0x3C;
//     myOled->height      = H_64;
//     myOled->width       = W_128;

// configure the OLED
//     oledI2cConfig(&myOled);


#define DO_I2CERRLOGGING 0
#define DO_I2CDATLOGGING 0

/**
 * Font pixel size
 */
#define OLED_FONT_HEIGHT 8
#define OLED_FONT_WIDTH 6

/**
 * tty mode default
 */
#define OLED_DEFAULT_TTY_MODE false;

/**
 * Use as pin number if the reset line is not connected to an I/O pin. 
 * In this case, the reset signal must be generated by some other hardware.
 */
#define NO_RESET_PIN 255

/**
 * Driver for OLED displays with SSD1306 or SH1106 controller with write(), print(), println(), printf() support.
 * 
 * Supported display sizes: 196x16, 28x32 and 128x64 pixels.
 * This driver supports only displays with internal charge pump and I2C interface.
 * The I2C communication is done by software bit-banging the configurable I/O pins.
 * Communication errors are not handled.
 * 
 * The driver allocates 192, 512 or 1024 bytes memory on the heap for buffering.
 * 
 * The display is technically organized into "pages" which is a set of 8 horizontal lines.
 * For a 128x34 display the memory contains 4 pages each of 128 bytes. 
 * Each byte represents 8 pixels. Bit 0 is the top pixel, bit 7 is the bottom pixel.
 * 
 * Bitmap graphics have the same format with the exception that they can have any width. The
 * height is always a multiple of 8.
 * 
 * Text and bitmaps can be drawn to any position, but vertical positions at the
 * page boundaries (y=0, 8, 16, 24, 32, 40, 48, 56) provide better performance.
 * 
 * For all drawing functions, the coordinate 0,0 is the top left corner of the display.
 * After drawing into the buffer, you have to call the display() method to send the data to 
 * the display controller. Otherwise you won't see anything.
 * 
 * This driver is distributed without license. You may use it for free.
 * Author: Stefan Frings, 2017
 *
 * Update by:
 * Author: Fabio Durigon, 2018
 * email: develop@dury.it
 *
 */


// class OLED : public Print
// {
// public:
    
    /** Possible colors for drawing */
typedef enum tColor { BLACK, WHITE } tColor;
    
    /** Filling mode */
typedef enum tFillmode { HOLLOW, SOLID } tFillmode;
    
    /** Supported text sizes. Normal=6x8 pixels, Double=12x16 pixels */
typedef enum tFontScaling { NORMAL_SIZE, DOUBLE_SIZE } tFontScaling;
    
    /** Scroll effects supported by the display controller, note that there is no plain vertical scrolling */
typedef enum tScrollEffect { NO_SCROLLING=0, HORIZONTAL_RIGHT=0x26, HORIZONTAL_LEFT=0x27, DIAGONAL_RIGHT=0x29, DIAGONAL_LEFT=0x2A } tScrollEffect;

    /** Possible display width values **/
typedef enum tWidth { W_96=96, W_128=128, W_132=132 } tWidth;

    /** Possible display height values **/
typedef enum tHeight { H_16=16, H_32=32, H_64=64 } tHeight;

    /** Possible display controller **/
typedef enum tDisplayCtrl { CTRL_SSD1306, CTRL_SSD1309, CTRL_SH1106 } tDisplayCtrl;


typedef struct t_OledParams{
// the user must set these before calling oledI2cConfig
    i2c_inst_t      *i2c;           // pico I2C instance
    uint8_t         SDA_PIN;        // SDA hardware pin
    uint8_t         SCL_PIN;        // SCL hardware pin

    tDisplayCtrl    ctlrType;       // oled controller type

    uint8_t         i2c_address;    // controller I2C address
    tHeight         height;         // display height in pixels
    tWidth          width;          // display width in pixels
    bool            usingOffset;    // true for SH1106 using 132 pixel width

// the remainder are initialized when calling oledI2cConfig
//  or some can be changed with interface functions
    bool            fontInverted;   // @ true if the font is inverted
    tColor          color;          // @ text color
    tFontScaling    scaling;        // @ font size (DOUBLE or SINGLE)
    bool            ttyMode;        // @ true if display in tty text mode
    tScrollEffect   scroll_type;
    uint8_t         X;              // current print position column
    uint8_t         Y;              // current print position line

    uint8_t         pages;          // number of display pages
// largest buffer size
    int16_t         bufsize;        // size of the pixel buffer
    uint8_t         buffer[1024];   // pixel buffer for the display
                                    //  the size is sufficient for the largest display
} t_OledParams;

typedef struct t_OledTxtScroller{
    uint8_t X;
    uint8_t Y;
    uint16_t size;
    uint16_t position;
    uint8_t increment;
    char name[50];
    uint8_t wait_loop;
    bool doublesize;
} t_OledTxtScroller;
    
/**
 * Initialize the display controller structue and the
 *  I2C hardware controller
 */
uint8_t oledI2cConfig(t_OledParams *oled);

/**
 * Initialize the display controller, clean memory and switch output on.
 * 
 */
void oledInit(t_OledParams *oled);

/**
 * Will use offset for wired cases when controller uses SSH1106 132x64 but display is 128x64
 */
void oledSet_power(t_OledParams *oled, bool enable);
    
/**
 * Enable or disable the charge pump and display output. May be used to save power.
 * This command is executed by the display controller itself, hence it does not affect the buffer memory.
 * @param enable Whether to enable the display output.
 */
void set_power(t_OledParams *oled, bool enable);
       
/**
 * Enable display inverting. If enabled, then WHITE and BLACK are swapped.
 * This command is executed by the display controller itself, so it works very fast and does not affect
 * the buffer memory.
 * @param enable Whether to enable inverse output
 */
void oledSet_invert(t_OledParams *oled, bool enable);
    
/**
 * Set the contrast (brightness) of the display.
 * The value affects the electrical current throught the OLED segments in linear ratio.
 * But the eye reacts logarithmically. A medium brightnes of 128 looks almost as bright as the
 * maximum setting but increases the lifetime of the display a lot.
 * @param contrast Contrast value, default is 0x80.
 */
void oledSet_contrast(t_OledParams *oled, uint8_t contrast);
    
/**
 * Enable continuous scrolling. This is performed by the display controller itself without needing continuous 
 * communication and it does not affect the buffer memory.
 * For horizontal scrolling, you can decide whether the whole display or only a part of it shall scroll.
 * In case of diagonal scrolling, the vertical part affects always the whole display.
 * @param scroll_type Select the scroll effect, or NO_SCROLLING to disable it
 * @param first_page Defined which pages are affected by the horizontal scrolling (0-7). Each page contains 8 lines
 * @param last_page Defined which pages are affected by the horizontal scrolling (0-7). Each page contains 8 lines
 */
void oledSet_scrolling(t_OledParams *oled, tScrollEffect scroll_type, uint8_t first_page, uint8_t last_page, uint8_t speed);
       
/**
 * Scroll the display up, which leaves a number of black pixel lines at the bottom.
 * An optional delay time can be used to produce a smooth scrolling effect.
 * This is done by software, requiring continuous communication. This routine will block
 *  if the delay_ms parameter is > 0
 * @param num_lines Number of pixel lines to scroll the display content up.
 * @param delay_ms Delay time between each step, recommended values are either 0 or 20..60.
 */
void oledScroll_up(t_OledParams *oled, uint8_t num_lines, uint8_t delay_ms);
    
/**
 * Transfer the buffer memory data to the display controller.
 * You have to call this method after any drawing action into the buffer to make the change visible.
 * A call to this method takes several milliseconds.
 */
void oledDisplay(t_OledParams *oled);
    
/**
 * Fill the whole buffer memory with white or black color.
 * @param color The color to be used
 */
void oledClear(t_OledParams *oled, tColor color);

void oledDraw_simple_picture(t_OledParams *oled, uint8_t x0, uint8_t y0, uint8_t size_x,  uint8_t size_y, const uint8_t *data, bool invert);

/**
 * Draw a bitmap from RAM. The raw data format is explained in the description of this class.
 * @param x Pixel position of the upper left corner
 * @param y Pixel position of the upper left corner
 * @param width Width of the bitmap in pixels
 * @param height Height of the bitmap in pixels. Must be a multiple of 8
 * @param data Raw data, number of bytes must be width*height/8
 * @param color Color to draw with
 */
void oledDraw_bitmap(t_OledParams *oled, uint8_t x, uint8_t y, uint8_t bitmap_width, uint8_t bitmap_height, const uint8_t* data, tColor color);
    
/**
 * Draw a bitmap from program memory (aka FLASH). The raw data format is explained in the description of this class.
 * @param x Pixel position of the upper left corner
 * @param y Pixel position of the upper left corner
 * @param width Width of the bitmap in pixels
 * @param height Height of the bitmap in pixels. Must be a multiple of 8
 * @param data Raw data, number of bytes must be width*height/8
 * @param color Color to draw with
 */
void oledDraw_bitmap_P(t_OledParams *oled, uint8_t x, uint8_t y, uint8_t bitmap_width, uint8_t bitmap_height, const uint8_t* data, tColor color);
    
/**
 * Draw a character.
 * @param x Pixel position of the upper left corner
 * @param y Pixel position of the upper left corner
 * @param c The character code. Supports US-ASCII characters and german umlauts. See source code of oled.cpp
 * @param scaling Scaling factor. Can be used to double the size of the output. The normal font size is 6x8
 * @param color Color to draw with
 */
size_t oledDraw_character(t_OledParams *oled, uint8_t x, uint8_t y, char c, tFontScaling scaling, tColor color);
    
/**
 * Draw a C string from RAM, which is a NULL terminated array of characters.
 * @param x Pixel position of the upper left corner
 * @param y Pixel position of the upper left corner
 * @param s The string to draw. Supports US-ASCII characters and german umlauts. See source code of oled.cpp
 * @param scaling Scaling factor. Can be used to double the size of the output. The normal font size is 6x8
 * @param color Color to draw with
 */
void oledDraw_string(t_OledParams *oled, uint8_t x, uint8_t y, const char* s, tFontScaling scaling, tColor color);

//                  Depricated for the Raspberry Pi Pico
//     /**
//      * Draw a C string from program memory (aka FLASH), which is a NULL terminated array of characters.
//      * @param x Pixel position of the upper left corner
//      * @param y Pixel position of the upper left corner
//      * @param s The string to draw. Supports US-ASCII characters and german umlauts. See source code of oled.cpp
//      * @param scaling Scaling factor. Can be used to double the size of the output. The normal font size is 6x8
//      * @param color Color to draw with
//      */
//     void draw_string_P(uint_fast8_t x, uint_fast8_t y, const char* s, tFontScaling scaling=NORMAL_SIZE, tColor color=WHITE);      
   
/**
 * Draw a single pixel.
 * @param x,y Position of the pixel
 * @param color Color to draw with
 */
void oledDraw_pixel(t_OledParams *oled, uint8_t x, uint8_t y, tColor color);
    
/**
 * Draw a line.
 * @param x0,y0 Start point of the line
 * @param x1,y1 End point of the line
 * @param color Color to draw with
 */
void oledDraw_line(t_OledParams *oled, uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, tColor color);
    
/**
 * Draw a circle.
 * @param x,y Center position of the circle
 * @param radius Radius of the circle
 * @param fillMode Whether the circle is filled with the color
 * @param color Color to draw with     
 */
void oledDraw_circle(t_OledParams *oled, uint8_t x0, uint8_t y0, uint8_t radius, tFillmode fillMode, tColor color);
    
/**
 * Draw a rectangle.
 * @param x0,y0 Upper left corner
 * @param x1,y1 Lower right corner
 * @param fillMode Whether the rectangle is filled with the color
 * @param color Color to draw with
 */
void oledDraw_rectangle(t_OledParams *oled, uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, tFillmode fillMode, tColor color);

/**
 * Write a character at current X,Y coordinates.
 * X coordinate will be moved by OLED_FONT_WIDTH value
 * * If the string contains a \r or \n and ttyMode is true, Y coordinate will be incremented
 * by OLED_FONT_HEIGHT value
 * This function overrides write(...) in Print.cpp of Arduino core
 * @param c character to write
 * @return 1 on succeed, otherwise 0.
 */
size_t oledWriteChar(t_OledParams *oled, uint8_t c);

/**
 * Write a sting at current X,Y coordinates.
 * X coordinate will be moved by (size*OLED_FONT_WIDTH) pixels.
 * If ttyMode is true display() will be called to redraw screen.
 * This function overrides write(...) in Print.cpp of Arduino core
 * @param buffer The string to be printed
 * @param size The length of the string
 * @return Nr of characters written.
 */
size_t oledWriteStr(t_OledParams *oled, const uint8_t *buffer, size_t len);

/**
 * Display a bitmap
 * 
 * @param data pointer to a bitmap data structure
 * @param size size of the bit map
 *
 * uses oledBmp_show_image_with_offset()
*/
void oledBmp_show_image(t_OledParams *oled, const uint8_t *data, const long size);

/**
 * Display a bitmap zt the location given by the x and y offsets.
 *  It is the user's responsibility to ensure the bitmap will fit the geometry
 *      of the display.
 * 
 * @param data      pointer to a bitmap data structure
 * @param size      size of the bit map
 * @param x_offset  column at which to start drawing the image
 * @param y_offset  line at which to start drawing the image
 * 
*/
void oledBmp_show_image_with_offset(t_OledParams *oled, const uint8_t *data, const long size, uint32_t x_offset, uint32_t y_offset);


/**
 * Same as printf width x and y coordinate set
 * @param x Pixel position of the upper left corner
 * @param y Pixel position of the upper left corner
 * @param format Format string same in printf
 * @param ... Args for formatted string
 * @return Len of written string
 */
size_t oledPrintfXy(t_OledParams *oled, uint8_t x, uint8_t y, const char *format, ...);

//     size_t printf(const char *format, ...);
size_t oledPrintf(t_OledParams *oled, const char *format, ...);


/**
 * Set cursor position
 */
void oledSetCursor(t_OledParams *oled, uint8_t x, uint8_t y);


/**
 * Set terminal mode on/off
 * @param Enabled If true, driver automatically scroll-up to one text line (height of font) when
 * a printing function (that doesn't use coordinate) reach the bottom of the screen.
 * Es.
 * When the cursor Y position is at the last text line and you use println() or writeln(),
 * the text on the the screen scrolls up and first line of text disappears
 */
void oledSetTTYMode(t_OledParams *oled, bool enabled);

//     // ************************ U8g2 wrappers ************************

    /**
 * @brief Draw a C, NULL terminated string from RAM, using column and row positioning.
 * Wrapper for U8g2 library API compatibility.
 * 
 * @param col column position where start to write (zero based).
 * @param row row position where start to write (zero based).
 * @param s The string to draw. Supports US-ASCII characters and german umlauts. See source code of oled.cpp
 * @param scaling Scaling factor. Can be used to double the size of the output. The normal font size is 6x8
 * @param color Color to draw with
 */
void oledDrawString(t_OledParams *oled, uint8_t col, uint8_t row, const char* s, tFontScaling scaling, tColor color);

/**
 * @brief Set inverted font write.
 * Wrapper for U8g2 library API compatibility.
 */
void oledInverse(t_OledParams *oled);

/**
 * @brief Set normal (not inverted) font wite.
 * Wrapper for U8g2 library API compatibility.
 */
void oledNoInverse(t_OledParams *oled);
    
/** Draw a byte into the buffer */
void oledDraw_byte(t_OledParams *oled, uint8_t x, uint8_t y, uint8_t b, tColor color);
    
/** Draw multiple bytes into the buffer */
void oledDraw_bytes(t_OledParams *oled, uint8_t x, uint8_t y, const uint8_t* data, uint8_t size, tFontScaling scaling, tColor color, bool useProgmem);


/**
 * @brief Enable  inverted print.
 * 
 * @param oled      pointer to a t_OledParams structure
 * @param enabled   true enables inverted font
 *                  false enables normal fong
 */
void oledSet_font_inverted(t_OledParams *oled, bool enabled);

// /**
//  * @brief Enable inverted print.
//  * 
//  * @param oled pointer to a t_OledParams structure
//  */
// void oledInverse(t_OledParams *oled);

// /**
//  * @brief Disable inverted print.
//  * 
//  * @param oled pointer to a t_OledParams structure
//  */
// void oledNoInverse(t_OledParams *oled)


/**
 * @brief Convert X coordinate to column index.
 * 
 * @param x Pixel coordinate of horizontal position.
 * @return Column index (zero based).
 */
uint_fast8_t ToCol(uint8_t x);

/**
 * @brief Convert Y coordinate to row index.
 * 
 * @param y Pixel coordinate of vertical position.
 * @return Row index (zero based).
 */
uint_fast8_t ToRow(uint8_t y);

/**
 * @brief Convert column index to X coordinate.
 * 
 * @param col Index of column (zero based).
 * @return X position coordinate.
 */
uint_fast8_t ToX(uint8_t col);

/**
 * @brief Convert row index to Y coordinate.
 * 
 * @param row Index of row (zero based).
 * @return Y position coordinate.
 */
uint_fast8_t ToY(uint8_t row);

#ifdef __cplusplus
}
#endif


